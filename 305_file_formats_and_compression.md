文件格式和压缩
=============
**文件格式**

WiredTiger支持两种底层文件格式：行存和列存，都是B+树实现的键值存储。WiredTiger同时支持[LSM树](304_log_structured_merge_trees.md)。

在行存中，键和数据都是变长字节字符串。在列存中，键是64位的记录号（key_format类型'r'），值是变长或定长的字节字符串。

通常，在每次查找都需要所有的列时行存的查询更快（因为只有一个元数据页需要缓存和查找）。列存在查询只需要列的一个子集时更快（因为列能够被分解成多个文件，而只有要返回的列需要在缓存中）。

行存的键和值以及变长的列存值，长度为（4GB-512B）。键和值的大小超出普通页时在文件中按溢出项存储，访问时需要额外的文件IO。

定长的列存值（value_format类型't'）被限制为8位，只有0-255之间的值能够存储。另外，没有带外定长“被删除”的值，删除值与存储0值相同。同样的原因，存储0值会使游标跳过记录。

WiredTiger不支持重复的数据项：对于任意给定的键只能有一个值与之对应，由应用程序复制创建唯一的键值对。

WiredTiger以块（block）为单位从底层文件分配空间。WiredTiger支持的最小文件分配单元是512字节，最大是512MB。文件偏移是8字节的有符号值，使得文件最大大小非常的大。

**选择文件格式**

行存格式是大多数应用程序的默认选择。当主键是记录号的时候，将列存储到分开的文件中有优势，或者基础数据时位的集合时，列存格式可能是更好的选择。

行存和列存都能维持高容量的写，但是对于需要保持极大的写吞吐量的数据集，[LSM树](304_log_structured_merge_trees.md)通常是更好的选择。对于不需要极大的写吞吐量的应用程序，行存或列存是一个更好的选择，因为读吞吐量比LSM树要好（增加额外的读线程时效果更明显）。

使用复杂的模式的应用也许能从使用多种存储格式中受益，即是说，在数据库中使用多种格式的组合，甚至在单独的表上（例如，一个稀疏的宽表，在主数据上使用列存，而索引使用LSM树）。

最后，因为WiredTiger能够很容易的反复切换存储配置，当有任何问题的时候通常值得对可能的配置做基准测试。

**文件格式和压缩**

行存支持4种类型的压缩：键前缀压缩、字典压缩、哈夫曼编码和块压缩。
- 键前缀压缩通过在每个页上对任何相同的键前缀只存储一次，减少了内存中和磁盘上的对象的大小。

    代价是当在内存中的树上操作时需要更多的CPU和内存。特别是在有序的游标移动以反向的顺序从前缀压缩的页面通过时（不是正向）
，或者是在对键值对做随机查找时会分配足够多的内存以存放一些未压缩的键。因此，举个例子，如果键前缀压缩值为每个键节省了少量字节，那么实例化未压缩的键带来了额外的内存开销就意味着不值得使用键前缀压缩。更进一步，当磁盘开销是主要的考虑时，块压缩可能意味着前缀压缩用处不大。

    应用程序可以通过配置在使用前缀压缩前必须达到的最小字节数来限制前缀压缩的使用，在`WT_SESSION::create`方法上使用prefix_compression_min配置字符串来配置。

	默认不使用键前缀压缩。

- 字典压缩通过在每个页上对任何相同的值只存储一次减少了内存中和磁盘上的对象的大小。代价是在将页写到磁盘时需要少量额外的CPU和内存。

    默认不使用字典压缩。

- 哈夫曼编码通过压缩每个键值项减少了内存中和磁盘上的对象的大小，并且可以单独配置对键或值进行压缩。代价是当搜索内存中的树（如果键是编码的）、从内存中的树上返回值以及将页面写到磁盘时需要额外的CPU和内存。注意哈夫曼编码消耗的额外的CPU可能很高，这是需要考虑的（查看[哈夫曼编码]()以获取更多细节）。

    默认不使用哈夫曼编码。
	
- 块压缩通过压缩对象文件的块来检索磁盘占用。代价是当从磁盘读取页面以及将页面写到磁盘时需要额外的CPU和内存。注意块压缩消耗的额外的CPU可能很高，这是需要考虑的（查看[压缩器]()以获取更多细节）。

    默认不使用块压缩。
	
使用变长字节字符串值的列存支持4种类型的压缩：行程编码、字典压缩、哈夫曼编码和块压缩。
- 行程编码通过将连续重复的值只存储一次（有相关计数）减少了内存中和磁盘上的对象的大小。代价是在从内存中的树返回值时以及将页面写到磁盘时需要少量额外的CPU和内存。

    行程编码总是被使用并不能关闭。
	
- 字典压缩通过在每个页上对任何相同的值只存储一次减少了内存中和磁盘上的对象的大小。代价是在将页写到磁盘时需要少量额外的CPU和内存。

    默认不使用字典压缩。

- 哈夫曼编码通过压缩每个键值项减少了内存中和磁盘上的对象的大小，并且可以单独配置对键或值进行压缩。代价是当搜索内存中的树（如果键是编码的）、从内存中的树上返回值以及将页面写到磁盘时需要额外的CPU和内存。注意哈夫曼编码消耗的额外的CPU可能很高，这是需要考虑的（查看[哈夫曼编码]()以获取更多细节）。

    默认不使用哈夫曼编码。
	
- 块压缩通过压缩对象文件的块来检索磁盘占用。代价是当从磁盘读取页面以及将页面写到磁盘时需要额外的CPU和内存。注意块压缩消耗的额外的CPU可能很高，这是需要考虑的（查看[压缩器]()以获取更多细节）。

    默认不使用块压缩。
	
使用定长字节值的列存支持一种压缩类型：块压缩。
- 块压缩通过压缩对象文件的块来检索磁盘占用。代价是当从磁盘读取页面以及将页面写到磁盘时需要额外的CPU和内存。注意块压缩消耗的额外的CPU可能很高，这是需要考虑的（查看[压缩器]()以获取更多细节）。

    默认不使用块压缩。